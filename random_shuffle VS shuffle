/* З переліку алгоритмів бібліотеки STL мови С++ мене зацікавив такий алгоритм: std::random_shuffle
Його суть проста: він змінює порядок елементів в заданому діапазоні [first_elem, last_elem] на довільний порядок, простіше кажучи,
"рандомно" перемішує список, послідовність чи інтервал значень. Нижче приклад з використанням цього алгоритму:*\

#include <vector> // ДОЛОВ КОЛЬ 
#include <algorithm>
#include <iterator>
#include <iostream>
using namespace std;

int main()
{
    vector<int> test = { 1, 2, 3, 4, 5 }; // Створюємо вектор int-значень

    random_shuffle(test.begin(), test.end()); // Викликаємо метод random_shuffle, вказуючи на початок і кінець вектора

    copy(test.begin(), test.end(), ostream_iterator<int>(cout, " ")); // Копіюємо вектор в потік виведення для показу результату
    cout << "\n";
}

На консолі отримаємо: 5 2 4 3 1 ( Результат може бути іншим )

/* Однак ще існує метод std::shuffle. Він в точності повторює дії попереднього алгоритму std::random_shuflle. Нижче приклад
з використанням алгоритму std::shuffle: *\

#include <algorithm>
#include <iterator>
#include <vector>
#include <iostream>
#include <random>
using namespace std;

int main()
{
    vector<int> test = { 1,2,3,4,5 }; // Створюємо вектор int-значень
    int t = 0;

    shuffle(test.begin(), test.end(), default_random_engine(t)); // Викликаємо метод random_shuffle,
                                                                 // вказуючи на початок і кінець вектора
                                                                 // а також допоміжний метод default_random_engine
                                                                 // для "рандомного" розташування елементів

    copy(test.begin(), test.end(), ostream_iterator<int>(cout, " ")); // Копіюємо вектор в потік виведення для показу результату
    cout << "\n";

    return 0;
}

На консолі отримаємо: 5 4 1 3 2 ( Результат може бути іншим )

/* Що змінилось? Прогугливши, вияснилось, що методи shufflе та random_shuffle по своїй функціональності є одинаковими,
крім однієї деталі.

Метод random_shuffle для "рандомного" розташування елементів використовує функцію std::rand(), в той час, як метод shuffle
використовує так звану "UNRG" - Uniform Random Number Generator. В чому різниця? Функція std::rand() розкидує числа,
просто міняючи одне число на інше, яке знаходиться на rand() правіше від нього. Відомо, що функція rand() повертає значення
від 0 до RAND_MAX, тобто до 32767. Якщо ми працюємо з інтервалами, де є наприклад 200 тис. елементів, таке "рандомне" 
впорядкування чисел не буде дуже ефективним.

В той час Uniform Random Number Generator дозволяє використовувати такі методи як "mt19937" і "random_device",
або "default_random_engine", який я використав у своєму прикладі, для того, щоб повертати діапазон значень, який значно більший, 
ніж RAND_MAX. *\

/* Отже, можна зробити висновок, що при невеликих інтервалах, немає суттєвої різниці, що використовувати,
std::shuffle чи std::random_shuflle. І, по великому рахунку, std::shuffle є кращою версією std::random_shuflle.
Однак при великих інтервалах значень, >50 тис. елементів, std::shuffle підходить краще.
Щодо часу виконання програми - я не знайшов точних цифр в інтернеті, однак можу припустити, що при великих інтервалах значень,
std::shuffle використовує менше часу, ніж std::random_shuflle. *\

P.S. В інтернеті є дуже цікаве відео про те, чому програмістам варто відмовиись від використання rand().
https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful
